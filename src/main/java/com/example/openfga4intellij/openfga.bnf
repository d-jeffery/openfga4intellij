
{

  parserClass="com.example.openfga4intellij.parser.OpenFGAParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="OpenFGA"
  psiImplClassSuffix="Impl"
  psiPackage="com.example.openfga4intellij.psi"
  psiImplPackage="com.example.openfga4intellij.psi.impl"

  elementTypeHolderClass="com.example.openfga4intellij.psi.OpenFGATypes"
  elementTypeClass="com.example.openfga4intellij.psi.OpenFGAElementType"
  tokenTypeClass="com.example.openfga4intellij.psi.OpenFGATokenType"

    tokens = [
        MODEL = "model";
        SCHEMA = "schema";
        SCHEMA_VERSION_V1_1 = "1.1";
        TYPE = "type";
        RELATIONS = "relations";
        DEFINE = "define";

        HASH = "#";
        COLON = " =";
        WILDCARD = "*";
        L_SQUARE = "[";
        R_SQUARE = "]";
        COMMA = ",";

        AND = "and";
        OR = "or";
        BUT_NOT = "but not";
        FROM = "from";

        ALPHA_NUMERIC = "regexp:[a-zA-Z0-9_-]+";

        END_OF_LINE = "regexp:[\r\n]";
        WS = "regexp:[ \t]";

        SINGLE_LINE_COMMENT = "regexp:[ \t]*#.*"
    ]
}


openfgaFile ::= main
main ::= modelHeader typeDefs newline? EOF
indentation ::= indent
modelHeader ::= (multiLineComment newline)? MODEL spacing? (newline multiLineComment)? indentation SCHEMA spacing schemaVersion spacing?
typeDefs ::= typeDef*
typeDef ::= (newline multiLineComment)? newline TYPE spacing typeIdentifier spacing? (indentation RELATIONS spacing? relationDeclaration+)?
relationDeclaration ::= (newline multiLineComment)? indentation DEFINE spacing relationName spacing? COLON spacing? relationDef spacing?
relationDef ::= (relationDefDirectAssignment | relationDefGrouping) relationDefPartials?
relationDefPartials ::= relationDefPartialAllOr | relationDefPartialAllAnd | relationDefPartialAllButNot
relationDefPartialAllOr ::= (spacing relationDefOperatorOr spacing relationDefGrouping)+
relationDefPartialAllAnd ::= (spacing relationDefOperatorAnd spacing relationDefGrouping)+
relationDefPartialAllButNot ::= (spacing relationDefOperatorButNot spacing relationDefGrouping)+
relationDefDirectAssignment ::= L_SQUARE spacing? relationDefTypeRestriction spacing? (COMMA spacing? relationDefTypeRestriction)* spacing? R_SQUARE
relationDefRewrite ::= relationDefRelationOnSameObject | relationDefRelationOnRelatedObject
relationDefRelationOnSameObject ::= rewriteComputedusersetName
relationDefRelationOnRelatedObject ::= rewriteTuplesetComputedusersetName spacing relationDefKeywordFrom spacing rewriteTuplesetName
relationDefOperator ::= relationDefOperatorOr | relationDefOperatorAnd | relationDefOperatorButNot
relationDefOperatorAnd ::= AND
relationDefOperatorOr ::= OR
relationDefOperatorButNot ::= BUT_NOT
relationDefKeywordFrom ::= FROM
relationDefTypeRestriction ::= relationDefTypeRestrictionType | relationDefTypeRestrictionWildcard | relationDefTypeRestrictionUserset
relationDefTypeRestrictionType ::= identifier
relationDefTypeRestrictionRelation ::= identifier
relationDefTypeRestrictionWildcard ::= relationDefTypeRestrictionType COLON WILDCARD spacing?
relationDefTypeRestrictionUserset ::= relationDefTypeRestrictionType HASH relationDefTypeRestrictionRelation
relationDefGrouping ::= relationDefRewrite
rewriteComputedusersetName ::= identifier
rewriteTuplesetComputedusersetName ::= identifier
rewriteTuplesetName ::= identifier
relationName ::= identifier
typeIdentifier ::= identifier
comment ::= SINGLE_LINE_COMMENT
multiLineComment ::= comment (newline comment)*
spacing ::= WS+
newline ::= END_OF_LINE+
schemaVersion ::= SCHEMA_VERSION_V1_1
identifier ::= ALPHA_NUMERIC+
