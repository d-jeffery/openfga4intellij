
{

  parserClass="com.github.le_yams.openfga4intellij.parsing.OpenFGAParser"
  parserUtilClass="com.github.le_yams.openfga4intellij.parsing.OpenFGAParserUtil"

  psiClassPrefix="OpenFGA"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.le_yams.openfga4intellij.psi"
  psiImplPackage="com.github.le_yams.openfga4intellij.psi.impl"

  elementTypeHolderClass="com.github.le_yams.openfga4intellij.psi.OpenFGATypes"
  elementTypeClass="com.github.le_yams.openfga4intellij.parsing.OpenFGAElementType"
  tokenTypeClass="com.github.le_yams.openfga4intellij.parsing.OpenFGATokenType"

}

openfgaFile ::= main
main ::= headerMultiLineComment? newline? ( modelHeader | moduleHeader ) typeDefs newline? conditionDefs
moduleHeader ::= MODULE spacing? moduleName spacing?
modelHeader ::= MODEL spacing? multiLineComment? indentedLine1 SCHEMA spacing SCHEMA_VERSION spacing?
typeDefs ::= typeDef*
typeDef ::= multiLineComment? newline (EXTEND spacing)? TYPE spacing typeIdentifier spacing? (indentedLine1 RELATIONS spacing? relationDeclaration+)?
relationDeclaration ::= multiLineComment? indentedLine2 DEFINE spacing relationName spacing? COLON spacing? relationDef spacing?

relationDef ::= (relationDefDirectAssignment | relationDefGrouping | relationRecurse) relationDefPartials?
relationDefNoDirect ::= (relationDefGrouping | relationRecurseNoDirect) (relationDefPartials)?;
relationDefPartials ::=
    (spacing OR spacing (relationDefGrouping | relationRecurseNoDirect))+
    | (spacing AND spacing (relationDefGrouping | relationRecurseNoDirect))+
    | (spacing BUT_NOT spacing (relationDefGrouping | relationRecurseNoDirect));
relationRecurse ::= L_PAREN spacing? (relationDef | relationRecurseNoDirect) spacing? R_PAREN;
relationRecurseNoDirect ::= L_PAREN spacing? (relationDefNoDirect | relationRecurseNoDirect) spacing? R_PAREN;
relationDefDirectAssignment ::= L_SQUARE spacing? relationDefTypeRestriction spacing? (COMMA spacing? relationDefTypeRestriction)* spacing? R_SQUARE

relationDefTypeRestrictionBase ::= relationDefTypeRestrictionWildcard | relationDefTypeRestrictionUserset | relationDefTypeRestrictionRelation
relationDefTypeRestriction ::= relationDefTypeRestrictionBase (spacing WITH spacing conditionNameRef)?

relationDefRewrite ::= relationDefRelationOnRelatedObject | relationDefRelationOnSameObject
relationDefRelationOnSameObject ::= rewriteComputedusersetName
relationDefRelationOnRelatedObject ::= rewriteTuplesetComputedusersetName spacing FROM spacing rewriteTuplesetName
relationDefTypeRestrictionRelation ::= typeReference
relationDefTypeRestrictionWildcard ::= typeReference COLON WILDCARD
relationDefTypeRestrictionUserset ::= typeReference HASH relationDefTypeRestrictionRelation
relationDefGrouping ::= relationDefRewrite
rewriteComputedusersetName ::= identifier
rewriteTuplesetComputedusersetName ::= identifier
rewriteTuplesetName ::= identifier
moduleName ::= identifier
relationName ::= identifier
typeIdentifier ::= identifier
typeReference ::= identifier

// Conditions
// https://github.com/google/cel-spec/blob/f9ce1ea675260361a667d29b79ee15fd9768028a/doc/langdef.md#syntax
conditionDefs ::= conditions*
conditions ::= (
    (headerMultiLineComment newline)?
    CONDITION spacing conditionName spacing?
    L_PAREN spacing? conditionParameter spacing? (COMMA spacing? conditionParameter spacing?)* newline? R_PAREN spacing?
    CONDITION_EXPRESSION
    ) newline?
conditionName ::= identifier
conditionNameRef ::= identifier
conditionParameter ::= newline? parameterName spacing? COLON spacing? parameterType
parameterName ::= identifier
parameterType ::= parameterTypeNames | (("map"|"list") LESS parameterTypeNames GREATER)
parameterTypeNames ::= ("bool"|"string"|"int"|"uint"|"double"|"duration"|"timestamp"|"ipaddress")

// Simple tokens
identifier ::= ALPHA_NUMERIC | MODEL | SCHEMA | TYPE | RELATION | MODULE | EXTEND
spacing ::= WHITESPACE+
indentedLine1 ::= newline IDENT1
indentedLine2 ::= newline IDENT2
newline ::= END_OF_LINE+
comment ::= SINGLE_LINE_COMMENT
headerMultiLineComment ::= comment (newline comment)*
multiLineComment ::= newline comment (newline comment)*